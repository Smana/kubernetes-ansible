---
- name: sync_container_cache | Starting check for cached item
  debug:
    verbosity: 1
    var: download

- set_fact:
    fname: "{{local_release_dir}}/containers/{{download.repo|regex_replace('/|\0|:', '_')}}:{{download.tag|default(download.sha256)|regex_replace('/|\0|:', '_')}}.tar"
  when:
    - download.enabled
    - download.container
  tags:
    - facts

- debug:
    msg: "fname: {{fname | default(omit)}}"

- name: sync_container_cache | Determine if container image is in cache
  stat:
    path: "{{ fname }}"
  delegate_to: localhost
  register: cache_image
  changed_when: false
  delegate_facts: no
  become: false
  when:
    - download.enabled
    - download.container
  tags:
    - facts

- name: sync_container_cache | Upload cached container image to node(s)
  synchronize:
    src: "{{ fname }}"
    dest: "{{ fname }}"
    use_ssh_args: "{{ has_bastion | default(false) }}"
    mode: push
  run_once: "{{ download_run_once }}"
  delegate_facts: no
  become: false
  register: upload_image
  until: upload_image is succeeded
  retries: 4
  delay: "{{ retry_stagger | random + 3 }}"
  when:
    - download.enabled
    - download.container
    - cache_image.stat.exists
    - (not download_run_once) or download_delegate==inventory_hostname
    - ansible_os_family not in ["CoreOS", "Container Linux by CoreOS"]
  tags:
    - upload
    - upgrade

# NOTE: If download_delegate==localhost, then the account running ansible requires
#       sudo rights to able to access docker or to be in the docker group. Running
#       ansible with ask-become-pass is mandatory if user is not in the docker group.
- name: sync_container_cache | Load container images on node(s)
  shell: "{{ docker_bin_dir }}/docker load < {{ fname }}"
  delegate_to: "{{ download_delegate if download_run_once or omit }}"
  run_once: "{{ download_run_once }}"
  when:
    - download.enabled
    - download.container
    - cache_image.stat.exists
    - ansible_os_family not in ["CoreOS", "Container Linux by CoreOS"]
  tags:
    - upload
    - upgrade
